{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isMesh(object) {\n  return object.isMesh;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef((_ref, forwardRef) => {\n  let {\n    children,\n    temporal,\n    frames = 40,\n    blend = 20,\n    scale = 10,\n    opacity = 1,\n    alphaTest = 0.65,\n    color = 'black',\n    resolution = 1024,\n    ...props\n  } = _ref;\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []); //const [lights, setLights] = React.useState<AccumulativeLightContext[]>([])\n\n  const material = React.useMemo(() => {\n    const mat = Object.assign(new THREE.MeshBasicMaterial({\n      opacity: 0,\n      transparent: true,\n      dithering: true,\n      depthWrite: false,\n      map: plm.progressiveLightMap2.texture\n    }), {\n      uniforms: {\n        ucolor: {\n          value: new THREE.Color(color)\n        },\n        alphaTest: {\n          value: 0\n        }\n      }\n    });\n\n    mat.onBeforeCompile = shader => {\n      mat.uniforms = shader.uniforms = { ...shader.uniforms,\n        ...mat.uniforms\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, `uniform vec3 ucolor;\n           uniform float alphaTest;\n           void main() {`);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);`);\n    };\n\n    return mat;\n  }, [color]);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      material.opacity = 0;\n      material.uniforms.alphaTest.value = 0;\n      api.count = 0;\n    },\n    update: function () {\n      let frames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      // Adapt the opacity-blend ratio to the number of frames\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.uniforms.alphaTest.value = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.uniforms.alphaTest.value = Math.min(alphaTest, material.uniforms.alphaTest.value + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, material, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, []);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    material: material,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null)));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef((_ref2, forwardRef) => {\n  let {\n    castShadow = true,\n    bias = 0,\n    mapSize = 512,\n    size = 5,\n    near = 0.5,\n    far = 500,\n    frames = 1,\n    position = [0, 0, 0],\n    radius = 1,\n    amount = 8,\n    intensity = 1,\n    ambient = 0.5,\n    ...props\n  } = _ref2;\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n});\n\nclass UVMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      vertexShader: 'void main() { gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }',\n      fragmentShader: 'void main() { discard; }'\n    });\n  }\n\n} // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene) {\n    let res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1024;\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.scene.background = null;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new UVMaterial();\n    this.targetMat = new THREE.MeshPhongMaterial({\n      shininess: 0\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isMesh(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.uvMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera) {\n    let blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":{"version":3,"names":["_extends","THREE","React","useThree","useFrame","isLight","object","isMesh","accumulativeContext","createContext","AccumulativeShadows","forwardRef","children","temporal","frames","blend","scale","opacity","alphaTest","color","resolution","props","gl","state","scene","camera","gPlane","useRef","gLights","plm","useState","ProgressiveLightMap","useLayoutEffect","configure","current","material","useMemo","mat","Object","assign","MeshBasicMaterial","transparent","dithering","depthWrite","map","progressiveLightMap2","texture","uniforms","ucolor","value","Color","onBeforeCompile","shader","fragmentShader","replace","api","lights","Map","Math","max","Infinity","count","reset","clear","update","min","visible","prepare","i","forEach","light","finish","useImperativeHandle","createElement","traverse","ref","Provider","receiveShadow","rotation","PI","RandomizedLight","castShadow","bias","mapSize","size","near","far","position","radius","amount","intensity","ambient","length","Vector3","parent","useContext","useCallback","l","random","set","MathUtils","randFloatSpread","lambda","acos","phi","cos","abs","sin","group","uuid","delete","Array","from","_","index","key","attach","args","UVMaterial","ShaderMaterial","constructor","vertexShader","renderer","res","background","buffer1Active","meshes","format","test","navigator","userAgent","HalfFloatType","FloatType","progressiveLightMap1","WebGLRenderTarget","type","uvMat","targetMat","MeshPhongMaterial","shininess","previousShadowMap","averagingWindow","slice","bodyStart","indexOf","setRenderTarget","push","mesh","blendWindow","activeMap","inactiveMap","render"],"sources":["/Users/adamgif/Documents/Adam n Gif Studio/Project/Website/UT/React/eisapp/node_modules/@react-three/drei/core/AccumulativeShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isMesh(object) {\n  return object.isMesh;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.65,\n  color = 'black',\n  resolution = 1024,\n  ...props\n}, forwardRef) => {\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []); //const [lights, setLights] = React.useState<AccumulativeLightContext[]>([])\n\n  const material = React.useMemo(() => {\n    const mat = Object.assign(new THREE.MeshBasicMaterial({\n      opacity: 0,\n      transparent: true,\n      dithering: true,\n      depthWrite: false,\n      map: plm.progressiveLightMap2.texture\n    }), {\n      uniforms: {\n        ucolor: {\n          value: new THREE.Color(color)\n        },\n        alphaTest: {\n          value: 0\n        }\n      }\n    });\n\n    mat.onBeforeCompile = shader => {\n      mat.uniforms = shader.uniforms = { ...shader.uniforms,\n        ...mat.uniforms\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, `uniform vec3 ucolor;\n           uniform float alphaTest;\n           void main() {`);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);`);\n    };\n\n    return mat;\n  }, [color]);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      material.opacity = 0;\n      material.uniforms.alphaTest.value = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.uniforms.alphaTest.value = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.uniforms.alphaTest.value = Math.min(alphaTest, material.uniforms.alphaTest.value + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, material, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, []);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    material: material,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null)));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n});\n\nclass UVMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      vertexShader: 'void main() { gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }',\n      fragmentShader: 'void main() { discard; }'\n    });\n  }\n\n} // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.scene.background = null;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new UVMaterial();\n    this.targetMat = new THREE.MeshPhongMaterial({\n      shininess: 0\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isMesh(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.uvMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera, blendWindow = 100) {\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}